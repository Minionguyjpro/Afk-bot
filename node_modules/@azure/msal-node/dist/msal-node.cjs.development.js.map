{"version":3,"file":"msal-node.cjs.development.js","sources":["../src/utils/Constants.ts","../src/utils/NetworkUtils.ts","../src/network/HttpClient.ts","../src/config/Configuration.ts","../src/crypto/GuidGenerator.ts","../src/utils/EncodingUtils.ts","../src/crypto/HashUtils.ts","../src/crypto/PkceGenerator.ts","../src/crypto/CryptoProvider.ts","../src/cache/serializer/Deserializer.ts","../src/cache/serializer/Serializer.ts","../src/cache/NodeStorage.ts","../src/cache/TokenCache.ts","../src/packageMetadata.ts","../src/error/NodeAuthError.ts","../src/client/ClientApplication.ts","../src/network/LoopbackClient.ts","../src/client/PublicClientApplication.ts","../src/client/ClientAssertion.ts","../src/client/ConfidentialClientApplication.ts","../src/cache/distributed/DistributedCachePlugin.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * http methods\n */\nexport enum HttpMethod {\n    GET = \"get\",\n    POST = \"post\",\n}\n\nexport enum HttpStatus {\n    SUCCESS_RANGE_START = 200,\n    SUCCESS_RANGE_END = 299,\n    REDIRECT = 302,\n    CLIENT_ERROR_RANGE_START = 400,\n    CLIENT_ERROR_RANGE_END = 499,\n    SERVER_ERROR_RANGE_START = 500,\n    SERVER_ERROR_RANGE_END = 599\n}\n\nexport enum ProxyStatus {\n    SUCCESS_RANGE_START = 200,\n    SUCCESS_RANGE_END = 299,\n    SERVER_ERROR = 500\n}\n\n/**\n * Constants used for region discovery\n */\nexport const REGION_ENVIRONMENT_VARIABLE = \"REGION_NAME\";\n\n/**\n * Constant used for PKCE\n */\nexport const RANDOM_OCTET_SIZE = 32;\n\n/**\n * Constants used in PKCE\n */\nexport const Hash = {\n    SHA256: \"sha256\",\n};\n\n/**\n * Constants for encoding schemes\n */\nexport const CharSet = {\n    CV_CHARSET:\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\",\n};\n\n/**\n * Cache Constants\n */\nexport const CACHE = {\n    FILE_CACHE: \"fileCache\",\n    EXTENSION_LIB: \"extenstion_library\",\n};\n\n/**\n * Constants\n */\nexport const Constants = {\n    MSAL_SKU: \"msal.js.node\",\n    JWT_BEARER_ASSERTION_TYPE: \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n    AUTHORIZATION_PENDING: \"authorization_pending\",\n    HTTP_PROTOCOL: \"http://\",\n    LOCALHOST: \"localhost\"\n};\n\n/**\n * API Codes for Telemetry purposes.\n * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs\n * 0-99 Silent Flow\n * 600-699 Device Code Flow\n * 800-899 Auth Code Flow\n */\nexport enum ApiId {\n    acquireTokenSilent = 62,\n    acquireTokenByUsernamePassword = 371,\n    acquireTokenByDeviceCode = 671,\n    acquireTokenByClientCredential = 771,\n    acquireTokenByCode = 871,\n    acquireTokenByRefreshToken = 872\n}\n\n/**\n * JWT  constants\n */\nexport const JwtConstants = {\n    ALGORITHM: \"alg\",\n    RSA_256: \"RS256\",\n    X5T: \"x5t\", \n    X5C: \"x5c\",\n    AUDIENCE: \"aud\",\n    EXPIRATION_TIME: \"exp\",\n    ISSUER: \"iss\",\n    SUBJECT: \"sub\",\n    NOT_BEFORE: \"nbf\",\n    JWT_ID: \"jti\",\n};\n\nexport const LOOPBACK_SERVER_CONSTANTS = {\n    INTERVAL_MS: 100,\n    TIMEOUT_MS: 5000\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { NetworkResponse } from \"@azure/msal-common\";\n\nexport class NetworkUtils {\n    static getNetworkResponse<T>(headers: Record<string, string>, body: T, statusCode: number): NetworkResponse<T> {\n        return {\n            headers: headers,\n            body: body,\n            status: statusCode,\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    INetworkModule,\n    NetworkRequestOptions,\n    NetworkResponse\n} from \"@azure/msal-common\";\nimport { HttpMethod, Constants, HttpStatus, ProxyStatus } from \"../utils/Constants\";\nimport { NetworkUtils } from \"../utils/NetworkUtils\";\nimport http from \"http\";\nimport https from \"https\";\n\n/**\n * This class implements the API for network requests.\n */\nexport class HttpClient implements INetworkModule {\n\n    /**\n     * Http Get request\n     * @param url\n     * @param options\n     */\n    async sendGetRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions,\n    ): Promise<NetworkResponse<T>> {\n        if (options?.proxyUrl) {\n            return networkRequestViaProxy(url, HttpMethod.GET, options);\n        } else {\n            return networkRequestViaHttps(url, HttpMethod.GET, options);\n        }\n    }\n\n    /**\n     * Http Post request\n     * @param url\n     * @param options\n     */\n    async sendPostRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions,\n        cancellationToken?: number,\n    ): Promise<NetworkResponse<T>> {\n        if (options?.proxyUrl) {\n            return networkRequestViaProxy(url, HttpMethod.POST, options, cancellationToken);\n        } else {\n            return networkRequestViaHttps(url, HttpMethod.POST, options, cancellationToken);\n        }\n    }\n}\n\nconst networkRequestViaProxy = <T>(\n    url: string,\n    httpMethod: string,\n    options: NetworkRequestOptions,\n    timeout?: number,\n): Promise<NetworkResponse<T>> => {\n    const headers = options?.headers || {} as Record<string, string>;\n    const proxyUrl = new URL(options?.proxyUrl || \"\");\n    const destinationUrl = new URL(url);\n\n    // \"method: connect\" must be used to establish a connection to the proxy\n    const tunnelRequestOptions: https.RequestOptions = {\n        host: proxyUrl.hostname,\n        port: proxyUrl.port,\n        method: \"CONNECT\",\n        path: destinationUrl.hostname,\n        headers: headers,\n    };\n\n    if (timeout) {\n        tunnelRequestOptions.timeout = timeout;\n    }\n\n    // compose a request string for the socket\n    let postRequestStringContent: string = \"\";\n    if (httpMethod === HttpMethod.POST) {\n        const body = options?.body || \"\";\n        postRequestStringContent =\n            \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n            `Content-Length: ${body.length}\\r\\n` +\n            `\\r\\n${body}`;\n    }\n    const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\\r\\n` +\n        `Host: ${destinationUrl.host}\\r\\n` +\n        \"Connection: close\\r\\n\" +\n        postRequestStringContent +\n        \"\\r\\n\";\n\n    return new Promise<NetworkResponse<T>>(((resolve, reject) => {\n        const request = http.request(tunnelRequestOptions);\n\n        if (tunnelRequestOptions.timeout) {\n            request.on(\"timeout\", () => {\n                request.destroy();\n                reject(new Error(\"Request time out\"));\n            });\n        }\n\n        request.end();\n\n        // establish connection to the proxy\n        request.on(\"connect\", (response, socket) => {\n            const proxyStatusCode = response?.statusCode || ProxyStatus.SERVER_ERROR;\n            if ((proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START) || (proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END)) {\n                request.destroy();\n                socket.destroy();\n                reject(new Error(`Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${response?.statusMessage || \"Unknown\"}`));\n            }\n            if (tunnelRequestOptions.timeout) {\n                socket.setTimeout(tunnelRequestOptions.timeout);\n                socket.on(\"timeout\", () => {\n                    request.destroy();\n                    socket.destroy();\n                    reject(new Error(\"Request time out\"));\n                });\n            }\n\n            // make a request over an HTTP tunnel\n            socket.write(outgoingRequestString);\n\n            const data: Buffer[] = [];\n            socket.on(\"data\", (chunk) => {\n                data.push(chunk);\n            });\n\n            socket.on(\"end\", () => {\n                // combine all received buffer streams into one buffer, and then into a string\n                const dataString = Buffer.concat([...data]).toString();\n\n                // separate each line into it's own entry in an arry\n                const dataStringArray = dataString.split(\"\\r\\n\");\n                // the first entry will contain the statusCode and statusMessage\n                const httpStatusCode = parseInt(dataStringArray[0].split(\" \")[1]);\n                // remove \"HTTP/1.1\" and the status code to get the status message\n                const statusMessage = dataStringArray[0].split(\" \").slice(2).join(\" \");\n                // the last entry will contain the body\n                const body = dataStringArray[dataStringArray.length - 1];\n\n                // everything in between the first and last entries are the headers\n                const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);\n\n                // build an object out of all the headers\n                const entries = new Map();\n                headersArray.forEach((header) => {\n                    /**\n                     * the header might look like \"Content-Length: 1531\", but that is just a string\n                     * it needs to be converted to a key/value pair\n                     * split the string at the first instance of \":\"\n                     * there may be more than one \":\" if the value of the header is supposed to be a JSON object\n                     */\n                    const headerKeyValue = header.split(new RegExp(/:\\s(.*)/s));\n                    const headerKey = headerKeyValue[0];\n                    let headerValue = headerKeyValue[1];\n\n                    // check if the value of the header is supposed to be a JSON object\n                    try {\n                        const object = JSON.parse(headerValue);\n\n                        // if it is, then convert it from a string to a JSON object\n                        if (object && (typeof object === \"object\")) {\n                            headerValue = object;\n                        }\n                    } catch (e) {\n                        // otherwise, leave it as a string\n                    }\n\n                    entries.set(headerKey, headerValue);\n                });\n                const headers = Object.fromEntries(entries);\n\n                const parsedHeaders = headers as Record<string, string>;\n                const networkResponse = NetworkUtils.getNetworkResponse(\n                    parsedHeaders,\n                    parseBody(httpStatusCode, statusMessage, parsedHeaders, body) as T,\n                    httpStatusCode\n                );\n\n                if (((httpStatusCode < HttpStatus.SUCCESS_RANGE_START) || (httpStatusCode > HttpStatus.SUCCESS_RANGE_END)) &&\n                    // do not destroy the request for the device code flow\n                    networkResponse.body[\"error\"] !== Constants.AUTHORIZATION_PENDING) {\n                    request.destroy();\n                }\n                resolve(networkResponse);\n            });\n\n            socket.on(\"error\", (chunk) => {\n                request.destroy();\n                socket.destroy();\n                reject(new Error(chunk.toString()));\n            });\n        });\n\n        request.on(\"error\", (chunk) => {\n            request.destroy();\n            reject(new Error(chunk.toString()));\n        });\n    }));\n};\n\nconst networkRequestViaHttps = <T>(\n    url: string,\n    httpMethod: string,\n    options?: NetworkRequestOptions,\n    timeout?: number,\n): Promise<NetworkResponse<T>> => {\n    const isPostRequest = httpMethod === HttpMethod.POST;\n    const body: string = options?.body || \"\";\n\n    const emptyHeaders: Record<string, string> = {};\n    const customOptions: https.RequestOptions = {\n        method: httpMethod,\n        headers: options?.headers || emptyHeaders,\n    };\n\n    if (timeout) {\n        customOptions.timeout = timeout;\n    }\n\n    if (isPostRequest) {\n        // needed for post request to work\n        customOptions.headers = {\n            ...customOptions.headers,\n            \"Content-Length\": body.length,\n        };\n    }\n\n    return new Promise<NetworkResponse<T>>((resolve, reject) => {\n        const request = https.request(url, customOptions);\n\n        if (timeout) {\n            request.on(\"timeout\", () => {\n                request.destroy();\n                reject(new Error(\"Request time out\"));\n            });\n        }\n\n        if (isPostRequest) {\n            request.write(body);\n        }\n\n        request.end();\n\n        request.on(\"response\", (response) => {\n            const headers = response.headers;\n            const statusCode = response.statusCode as number;\n            const statusMessage = response.statusMessage;\n\n            const data: Buffer[] = [];\n            response.on(\"data\", (chunk) => {\n                data.push(chunk);\n            });\n\n            response.on(\"end\", () => {\n                // combine all received buffer streams into one buffer, and then into a string\n                const body = Buffer.concat([...data]).toString();\n\n                const parsedHeaders = headers as Record<string, string>;\n                const networkResponse = NetworkUtils.getNetworkResponse(\n                    parsedHeaders,\n                    parseBody(statusCode, statusMessage, parsedHeaders, body) as T,\n                    statusCode\n                );\n\n                if (((statusCode < HttpStatus.SUCCESS_RANGE_START) || (statusCode > HttpStatus.SUCCESS_RANGE_END)) &&\n                    // do not destroy the request for the device code flow\n                    networkResponse.body[\"error\"] !== Constants.AUTHORIZATION_PENDING) {\n                    request.destroy();\n                }\n                resolve(networkResponse);\n            });\n        });\n\n        request.on(\"error\", (chunk) => {\n            request.destroy();\n            reject(new Error(chunk.toString()));\n        });\n    });\n};\n\n/**\n * Check if extra parsing is needed on the repsonse from the server\n * @param statusCode {number} the status code of the response from the server\n * @param statusMessage {string | undefined} the status message of the response from the server\n * @param headers {Record<string, string>} the headers of the response from the server\n * @param body {string} the body from the response of the server\n * @returns {Object} JSON parsed body or error object\n */\nconst parseBody = (statusCode: number, statusMessage: string | undefined, headers: Record<string, string>, body: string) => {\n    /*\n     * Informational responses (100 – 199)\n     * Successful responses (200 – 299)\n     * Redirection messages (300 – 399)\n     * Client error responses (400 – 499)\n     * Server error responses (500 – 599)\n     */\n    \n    let parsedBody;\n    try {\n        parsedBody = JSON.parse(body);\n    } catch (error) {\n        let errorType;\n        let errorDescriptionHelper;\n        if ((statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START) && (statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END)) {\n            errorType = \"client_error\";\n            errorDescriptionHelper = \"A client\";\n        } else if ((statusCode >= HttpStatus.SERVER_ERROR_RANGE_START) && (statusCode <= HttpStatus.SERVER_ERROR_RANGE_END)) {\n            errorType = \"server_error\";\n            errorDescriptionHelper = \"A server\";\n        } else {\n            errorType = \"unknown_error\";\n            errorDescriptionHelper = \"An unknown\";\n        }\n\n        parsedBody = {\n            error: errorType,\n            error_description: `${errorDescriptionHelper} error occured.\\nHttp status code: ${statusCode}\\nHttp status message: ${statusMessage || \"Unknown\"}\\nHeaders: ${JSON.stringify(headers)}`\n        };\n    }\n\n    return parsedBody;\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    LoggerOptions,\n    INetworkModule,\n    LogLevel,\n    ProtocolMode,\n    ICachePlugin,\n    Constants,\n    AzureCloudInstance,\n    AzureCloudOptions,\n    ApplicationTelemetry\n} from \"@azure/msal-common\";\nimport { HttpClient } from \"../network/HttpClient\";\n\n/**\n * - clientId               - Client id of the application.\n * - authority              - Url of the authority. If no value is set, defaults to https://login.microsoftonline.com/common.\n * - knownAuthorities       - Needed for Azure B2C and ADFS. All authorities that will be used in the client application. Only the host of the authority should be passed in.\n * - clientSecret           - Secret string that the application uses when requesting a token. Only used in confidential client applications. Can be created in the Azure app registration portal.\n * - clientAssertion        - Assertion string that the application uses when requesting a token. Only used in confidential client applications. Assertion should be of type urn:ietf:params:oauth:client-assertion-type:jwt-bearer.\n * - clientCertificate      - Certificate that the application uses when requesting a token. Only used in confidential client applications. Requires hex encoded X.509 SHA-1 thumbprint of the certificiate, and the PEM encoded private key (string should contain -----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY----- )\n * - protocolMode           - Enum that represents the protocol that msal follows. Used for configuring proper endpoints.\n * - skipAuthorityMetadataCache - A flag to choose whether to use or not use the local metadata cache during authority initialization. Defaults to false.\n * @public\n */\nexport type NodeAuthOptions = {\n    clientId: string;\n    authority?: string;\n    clientSecret?: string;\n    clientAssertion?: string;\n    clientCertificate?: {\n        thumbprint: string,\n        privateKey: string,\n        x5c?: string\n    };\n    knownAuthorities?: Array<string>;\n    cloudDiscoveryMetadata?: string;\n    authorityMetadata?: string;\n    clientCapabilities?: Array<string>;\n    protocolMode?: ProtocolMode;\n    azureCloudOptions?: AzureCloudOptions;\n    skipAuthorityMetadataCache?: boolean;\n};\n\n/**\n * Use this to configure the below cache configuration options:\n *\n * - cachePlugin   - Plugin for reading and writing token cache to disk.\n * @public\n */\nexport type CacheOptions = {\n    cachePlugin?: ICachePlugin;\n};\n\n/**\n * Type for configuring logger and http client options\n *\n * - logger                       - Used to initialize the Logger object; TODO: Expand on logger details or link to the documentation on logger\n * - networkClient                - Http client used for all http get and post calls. Defaults to using MSAL's default http client.\n * @public\n */\nexport type NodeSystemOptions = {\n    loggerOptions?: LoggerOptions;\n    networkClient?: INetworkModule;\n    proxyUrl?: string;\n};\n\nexport type NodeTelemetryOptions = {\n    application?: ApplicationTelemetry;\n};\n\n/**\n * Use the configuration object to configure MSAL and initialize the client application object\n *\n * - auth: this is where you configure auth elements like clientID, authority used for authenticating against the Microsoft Identity Platform\n * - cache: this is where you configure cache location\n * - system: this is where you can configure the network client, logger\n * @public\n */\nexport type Configuration = {\n    auth: NodeAuthOptions;\n    cache?: CacheOptions;\n    system?: NodeSystemOptions;\n    telemetry?: NodeTelemetryOptions;\n};\n\nconst DEFAULT_AUTH_OPTIONS: Required<NodeAuthOptions> = {\n    clientId: Constants.EMPTY_STRING,\n    authority: Constants.DEFAULT_AUTHORITY,\n    clientSecret: Constants.EMPTY_STRING,\n    clientAssertion: Constants.EMPTY_STRING,\n    clientCertificate: {\n        thumbprint: Constants.EMPTY_STRING,\n        privateKey: Constants.EMPTY_STRING,\n        x5c: Constants.EMPTY_STRING\n    },\n    knownAuthorities: [],\n    cloudDiscoveryMetadata: Constants.EMPTY_STRING,\n    authorityMetadata: Constants.EMPTY_STRING,\n    clientCapabilities: [],\n    protocolMode: ProtocolMode.AAD,\n    azureCloudOptions: {\n        azureCloudInstance: AzureCloudInstance.None,\n        tenant: Constants.EMPTY_STRING\n    },\n    skipAuthorityMetadataCache: false,\n};\n\nconst DEFAULT_CACHE_OPTIONS: CacheOptions = {};\n\nconst DEFAULT_LOGGER_OPTIONS: LoggerOptions = {\n    loggerCallback: (): void => {\n        // allow users to not set logger call back\n    },\n    piiLoggingEnabled: false,\n    logLevel: LogLevel.Info,\n};\n\nconst DEFAULT_SYSTEM_OPTIONS: Required<NodeSystemOptions> = {\n    loggerOptions: DEFAULT_LOGGER_OPTIONS,\n    networkClient: new HttpClient(),\n    proxyUrl: Constants.EMPTY_STRING,\n};\n\nconst DEFAULT_TELEMETRY_OPTIONS: Required<NodeTelemetryOptions> = {\n    application: {\n        appName: Constants.EMPTY_STRING,\n        appVersion: Constants.EMPTY_STRING\n    }\n};\n\nexport type NodeConfiguration = {\n    auth: Required<NodeAuthOptions>;\n    cache: CacheOptions;\n    system: Required<NodeSystemOptions>;\n    telemetry: Required<NodeTelemetryOptions>;\n};\n\n/**\n * Sets the default options when not explicitly configured from app developer\n *\n * @param auth - Authentication options\n * @param cache - Cache options\n * @param system - System options\n * @param telemetry - Telemetry options\n *\n * @returns Configuration\n * @public\n */\nexport function buildAppConfiguration({\n    auth,\n    cache,\n    system,\n    telemetry\n}: Configuration): NodeConfiguration {\n\n    return {\n        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\n        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },\n        system: { ...DEFAULT_SYSTEM_OPTIONS, ...system },\n        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry }\n    };\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IGuidGenerator } from \"@azure/msal-common\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport class GuidGenerator implements IGuidGenerator {\n    /**\n     *\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\n     * uuidv4 generates guids from cryprtographically-string random\n     */\n    generateGuid(): string {\n        return uuidv4();\n    }\n\n    /**\n     * verifies if a string is  GUID\n     * @param guid\n     */\n    isGuid(guid: string): boolean {\n        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        return regexGuid.test(guid);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants } from \"@azure/msal-common\";\n\nexport class EncodingUtils {\n    /**\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\n     * 'base64': Base64 encoding.\n     *\n     * @param str text\n     */\n    static base64Encode(str: string, encoding?: BufferEncoding): string {\n        return Buffer.from(str, encoding).toString(\"base64\");\n    }\n\n    /**\n     * encode a URL\n     * @param str\n     */\n    static base64EncodeUrl(str: string, encoding?: BufferEncoding): string {\n        return EncodingUtils.base64Encode(str, encoding)\n            .replace(/=/g, Constants.EMPTY_STRING)\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\");\n    }\n\n    /**\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\n     * 'base64': Base64 encoding.\n     *\n     * @param base64Str Base64 encoded text\n     */\n    static base64Decode(base64Str: string): string {\n        return Buffer.from(base64Str, \"base64\").toString(\"utf8\");\n    }\n\n    /**\n     * @param base64Str Base64 encoded Url\n     */\n    static base64DecodeUrl(base64Str: string): string {\n        let str = base64Str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        while (str.length % 4) {\n            str += \"=\";\n        }\n        return EncodingUtils.base64Decode(str);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Hash } from \"../utils/Constants\";\nimport crypto from \"crypto\";\n\nexport class HashUtils {\n    /**\n     * generate 'SHA256' hash\n     * @param buffer\n     */\n    sha256(buffer: string): Buffer {\n        return crypto\n            .createHash(Hash.SHA256)\n            .update(buffer)\n            .digest();\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants, PkceCodes } from \"@azure/msal-common\";\nimport { CharSet, RANDOM_OCTET_SIZE } from \"../utils/Constants\";\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\nimport { HashUtils } from \"./HashUtils\";\nimport crypto from \"crypto\";\n\n/**\n * https://tools.ietf.org/html/rfc7636#page-8\n */\nexport class PkceGenerator {\n    private hashUtils: HashUtils;\n\n    constructor() {\n        this.hashUtils = new HashUtils();\n    }\n    /**\n     * generates the codeVerfier and the challenge from the codeVerfier\n     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\n     */\n    async generatePkceCodes(): Promise<PkceCodes> {\n        const verifier = this.generateCodeVerifier();\n        const challenge = this.generateCodeChallengeFromVerifier(verifier);\n        return { verifier, challenge };\n    }\n\n    /**\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\n     */\n    private generateCodeVerifier(): string {\n        const charArr = [];\n        const maxNumber = 256 - (256 % CharSet.CV_CHARSET.length);\n        while (charArr.length <= RANDOM_OCTET_SIZE) {\n            const byte = crypto.randomBytes(1)[0];\n            if (byte >= maxNumber) {\n                /* \n                 * Ignore this number to maintain randomness.\n                 * Including it would result in an unequal distribution of characters after doing the modulo\n                 */\n                continue;\n            }\n            const index = byte % CharSet.CV_CHARSET.length;\n            charArr.push(CharSet.CV_CHARSET[index]);\n        }\n        const verifier: string = charArr.join(Constants.EMPTY_STRING);\n        return EncodingUtils.base64EncodeUrl(verifier);\n    }\n\n    /**\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\n     * @param codeVerifier\n     */\n    private generateCodeChallengeFromVerifier(codeVerifier: string): string {\n        return EncodingUtils.base64EncodeUrl(\n            this.hashUtils.sha256(codeVerifier).toString(\"base64\"), \n            \"base64\" \n        );\n    }\n\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ICrypto, PkceCodes } from \"@azure/msal-common\";\nimport { GuidGenerator } from \"./GuidGenerator\";\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\nimport { PkceGenerator } from \"./PkceGenerator\";\nimport { HashUtils } from \"./HashUtils\";\n\n/**\n * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\n * @public\n */\nexport class CryptoProvider implements ICrypto {\n    private pkceGenerator: PkceGenerator;\n    private guidGenerator: GuidGenerator;\n    private hashUtils: HashUtils;\n\n    constructor() {\n        // Browser crypto needs to be validated first before any other classes can be set.\n        this.pkceGenerator = new PkceGenerator();\n        this.guidGenerator = new GuidGenerator();\n        this.hashUtils = new HashUtils();\n    }\n\n    /**\n     * Creates a new random GUID - used to populate state and nonce.\n     * @returns string (GUID)\n     */\n    createNewGuid(): string {\n        return this.guidGenerator.generateGuid();\n    }\n\n    /**\n     * Encodes input string to base64.\n     * @param input - string to be encoded\n     */\n    base64Encode(input: string): string {\n        return EncodingUtils.base64Encode(input);\n    }\n\n    /**\n     * Decodes input string from base64.\n     * @param input - string to be decoded\n     */\n    base64Decode(input: string): string {\n        return EncodingUtils.base64Decode(input);\n    }\n\n    /**\n     * Generates PKCE codes used in Authorization Code Flow.\n     */\n    generatePkceCodes(): Promise<PkceCodes> {\n        return this.pkceGenerator.generatePkceCodes();\n    }\n\n    /**\n     * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node\n     */\n    getPublicKeyThumbprint(): Promise<string> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Removes cryptographic keypair from key store matching the keyId passed in\n     * @param kid \n     */\n    removeTokenBindingKey(): Promise<boolean> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Removes all cryptographic keys from Keystore\n     */\n    clearKeystore(): Promise<boolean> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node\n     */\n    signJwt(): Promise<string> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Returns the SHA-256 hash of an input string\n     */\n    async hashString(plainText: string): Promise<string> {\n        return EncodingUtils.base64EncodeUrl(\n            this.hashUtils.sha256(plainText).toString(\"base64\"), \n            \"base64\" \n        );\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { StringUtils, AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager } from \"@azure/msal-common\";\nimport { JsonCache, InMemoryCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\n\n/**\n * This class deserializes cache entities read from the file into in memory object types defined internally\n */\nexport class Deserializer {\n    /**\n     * Parse the JSON blob in memory and deserialize the content\n     * @param cachedJson\n     */\n    static deserializeJSONBlob(jsonFile: string): JsonCache {\n        const deserializedCache = StringUtils.isEmpty(jsonFile)\n            ? {}\n            : JSON.parse(jsonFile);\n        return deserializedCache;\n    }\n\n    /**\n     * Deserializes accounts to AccountEntity objects\n     * @param accounts\n     */\n    static deserializeAccounts(accounts: Record<string, SerializedAccountEntity>): AccountCache {\n        const accountObjects: AccountCache = {};\n        if (accounts) {\n            Object.keys(accounts).map(function (key) {\n                const serializedAcc = accounts[key];\n                const mappedAcc = {\n                    homeAccountId: serializedAcc.home_account_id,\n                    environment: serializedAcc.environment,\n                    realm: serializedAcc.realm,\n                    localAccountId: serializedAcc.local_account_id,\n                    username: serializedAcc.username,\n                    authorityType: serializedAcc.authority_type,\n                    name: serializedAcc.name,\n                    clientInfo: serializedAcc.client_info,\n                    lastModificationTime: serializedAcc.last_modification_time,\n                    lastModificationApp: serializedAcc.last_modification_app,\n                };\n                const account: AccountEntity = new AccountEntity();\n                CacheManager.toObject(account, mappedAcc);\n                accountObjects[key] = account;\n            });\n        }\n\n        return accountObjects;\n    }\n\n    /**\n     * Deserializes id tokens to IdTokenEntity objects\n     * @param idTokens\n     */\n    static deserializeIdTokens(idTokens: Record<string, SerializedIdTokenEntity>): IdTokenCache {\n        const idObjects: IdTokenCache = {};\n        if (idTokens) {\n            Object.keys(idTokens).map(function (key) {\n                const serializedIdT = idTokens[key];\n                const mappedIdT = {\n                    homeAccountId: serializedIdT.home_account_id,\n                    environment: serializedIdT.environment,\n                    credentialType: serializedIdT.credential_type,\n                    clientId: serializedIdT.client_id,\n                    secret: serializedIdT.secret,\n                    realm: serializedIdT.realm,\n                };\n                const idToken: IdTokenEntity = new IdTokenEntity();\n                CacheManager.toObject(idToken, mappedIdT);\n                idObjects[key] = idToken;\n            });\n        }\n        return idObjects;\n    }\n\n    /**\n     * Deserializes access tokens to AccessTokenEntity objects\n     * @param accessTokens\n     */\n    static deserializeAccessTokens(accessTokens: Record<string, SerializedAccessTokenEntity>): AccessTokenCache {\n        const atObjects: AccessTokenCache = {};\n        if (accessTokens) {\n            Object.keys(accessTokens).map(function (key) {\n                const serializedAT = accessTokens[key];\n                const mappedAT = {\n                    homeAccountId: serializedAT.home_account_id,\n                    environment: serializedAT.environment,\n                    credentialType: serializedAT.credential_type,\n                    clientId: serializedAT.client_id,\n                    secret: serializedAT.secret,\n                    realm: serializedAT.realm,\n                    target: serializedAT.target,\n                    cachedAt: serializedAT.cached_at,\n                    expiresOn: serializedAT.expires_on,\n                    extendedExpiresOn: serializedAT.extended_expires_on,\n                    refreshOn: serializedAT.refresh_on,\n                    keyId: serializedAT.key_id,\n                    tokenType: serializedAT.token_type,\n                    requestedClaims: serializedAT.requestedClaims,\n                    requestedClaimsHash: serializedAT.requestedClaimsHash\n                };\n                const accessToken: AccessTokenEntity = new AccessTokenEntity();\n                CacheManager.toObject(accessToken, mappedAT);\n                atObjects[key] = accessToken;\n            });\n        }\n\n        return atObjects;\n    }\n\n    /**\n     * Deserializes refresh tokens to RefreshTokenEntity objects\n     * @param refreshTokens\n     */\n    static deserializeRefreshTokens(refreshTokens: Record<string, SerializedRefreshTokenEntity>): RefreshTokenCache {\n        const rtObjects: RefreshTokenCache = {};\n        if (refreshTokens) {\n            Object.keys(refreshTokens).map(function (key) {\n                const serializedRT = refreshTokens[key];\n                const mappedRT = {\n                    homeAccountId: serializedRT.home_account_id,\n                    environment: serializedRT.environment,\n                    credentialType: serializedRT.credential_type,\n                    clientId: serializedRT.client_id,\n                    secret: serializedRT.secret,\n                    familyId: serializedRT.family_id,\n                    target: serializedRT.target,\n                    realm: serializedRT.realm,\n                };\n                const refreshToken: RefreshTokenEntity = new RefreshTokenEntity();\n                CacheManager.toObject(refreshToken, mappedRT);\n                rtObjects[key] = refreshToken;\n            });\n        }\n\n        return rtObjects;\n    }\n\n    /**\n     * Deserializes appMetadata to AppMetaData objects\n     * @param appMetadata\n     */\n    static deserializeAppMetadata(appMetadata: Record<string, SerializedAppMetadataEntity>): AppMetadataCache {\n        const appMetadataObjects: AppMetadataCache = {};\n        if (appMetadata) {\n            Object.keys(appMetadata).map(function (key) {\n                const serializedAmdt = appMetadata[key];\n                const mappedAmd = {\n                    clientId: serializedAmdt.client_id,\n                    environment: serializedAmdt.environment,\n                    familyId: serializedAmdt.family_id,\n                };\n                const amd: AppMetadataEntity = new AppMetadataEntity();\n                CacheManager.toObject(amd, mappedAmd);\n                appMetadataObjects[key] = amd;\n            });\n        }\n\n        return appMetadataObjects;\n    }\n\n    /**\n     * Deserialize an inMemory Cache\n     * @param jsonCache\n     */\n    static deserializeAllCache(jsonCache: JsonCache): InMemoryCache {\n        return {\n            accounts: jsonCache.Account\n                ? this.deserializeAccounts(jsonCache.Account)\n                : {},\n            idTokens: jsonCache.IdToken\n                ? this.deserializeIdTokens(jsonCache.IdToken)\n                : {},\n            accessTokens: jsonCache.AccessToken\n                ? this.deserializeAccessTokens(jsonCache.AccessToken)\n                : {},\n            refreshTokens: jsonCache.RefreshToken\n                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)\n                : {},\n            appMetadata: jsonCache.AppMetadata\n                ? this.deserializeAppMetadata(jsonCache.AppMetadata)\n                : {},\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache } from \"@azure/msal-common\";\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\n\nexport class Serializer {\n    /**\n     * serialize the JSON blob\n     * @param data\n     */\n    static serializeJSONBlob(data: JsonCache): string {\n        return JSON.stringify(data);\n    }\n\n    /**\n     * Serialize Accounts\n     * @param accCache\n     */\n    static serializeAccounts(accCache: AccountCache): Record<string, SerializedAccountEntity> {\n        const accounts: Record<string, SerializedAccountEntity> = {};\n        Object.keys(accCache).map(function (key) {\n            const accountEntity = accCache[key];\n            accounts[key] = {\n                home_account_id: accountEntity.homeAccountId,\n                environment: accountEntity.environment,\n                realm: accountEntity.realm,\n                local_account_id: accountEntity.localAccountId,\n                username: accountEntity.username,\n                authority_type: accountEntity.authorityType,\n                name: accountEntity.name,\n                client_info: accountEntity.clientInfo,\n                last_modification_time: accountEntity.lastModificationTime,\n                last_modification_app: accountEntity.lastModificationApp,\n            };\n        });\n\n        return accounts;\n    }\n\n    /**\n     * Serialize IdTokens\n     * @param idTCache\n     */\n    static serializeIdTokens(idTCache: IdTokenCache): Record<string, SerializedIdTokenEntity> {\n        const idTokens: Record<string, SerializedIdTokenEntity> = {};\n        Object.keys(idTCache).map(function (key) {\n            const idTEntity = idTCache[key];\n            idTokens[key] = {\n                home_account_id: idTEntity.homeAccountId,\n                environment: idTEntity.environment,\n                credential_type: idTEntity.credentialType,\n                client_id: idTEntity.clientId,\n                secret: idTEntity.secret,\n                realm: idTEntity.realm,\n            };\n        });\n\n        return idTokens;\n    }\n\n    /**\n     * Serializes AccessTokens\n     * @param atCache\n     */\n    static serializeAccessTokens(atCache: AccessTokenCache): Record<string, SerializedAccessTokenEntity> {\n        const accessTokens: Record<string, SerializedAccessTokenEntity> = {};\n        Object.keys(atCache).map(function (key) {\n            const atEntity = atCache[key];\n            accessTokens[key] = {\n                home_account_id: atEntity.homeAccountId,\n                environment: atEntity.environment,\n                credential_type: atEntity.credentialType,\n                client_id: atEntity.clientId,\n                secret: atEntity.secret,\n                realm: atEntity.realm,\n                target: atEntity.target,\n                cached_at: atEntity.cachedAt,\n                expires_on: atEntity.expiresOn,\n                extended_expires_on: atEntity.extendedExpiresOn,\n                refresh_on: atEntity.refreshOn,\n                key_id: atEntity.keyId,\n                token_type: atEntity.tokenType,\n                requestedClaims: atEntity.requestedClaims,\n                requestedClaimsHash: atEntity.requestedClaimsHash\n            };\n        });\n\n        return accessTokens;\n    }\n\n    /**\n     * Serialize refreshTokens\n     * @param rtCache\n     */\n    static serializeRefreshTokens(rtCache: RefreshTokenCache): Record<string, SerializedRefreshTokenEntity> {\n        const refreshTokens: Record<string, SerializedRefreshTokenEntity> = {};\n        Object.keys(rtCache).map(function (key) {\n            const rtEntity = rtCache[key];\n            refreshTokens[key] = {\n                home_account_id: rtEntity.homeAccountId,\n                environment: rtEntity.environment,\n                credential_type: rtEntity.credentialType,\n                client_id: rtEntity.clientId,\n                secret: rtEntity.secret,\n                family_id: rtEntity.familyId,\n                target: rtEntity.target,\n                realm: rtEntity.realm\n            };\n        });\n\n        return refreshTokens;\n    }\n\n    /**\n     * Serialize amdtCache\n     * @param amdtCache\n     */\n    static serializeAppMetadata(amdtCache: AppMetadataCache): Record<string, SerializedAppMetadataEntity> {\n        const appMetadata: Record<string, SerializedAppMetadataEntity> = {};\n        Object.keys(amdtCache).map(function (key) {\n            const amdtEntity = amdtCache[key];\n            appMetadata[key] = {\n                client_id: amdtEntity.clientId,\n                environment: amdtEntity.environment,\n                family_id: amdtEntity.familyId,\n            };\n        });\n\n        return appMetadata;\n    }\n\n    /**\n     * Serialize the cache\n     * @param jsonContent\n     */\n    static serializeAllCache(inMemCache: InMemoryCache): JsonCache {\n        return {\n            Account: this.serializeAccounts(inMemCache.accounts),\n            IdToken: this.serializeIdTokens(inMemCache.idTokens),\n            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\n            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\n            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccountEntity,\n    IdTokenEntity,\n    AccessTokenEntity,\n    RefreshTokenEntity,\n    AppMetadataEntity,\n    ServerTelemetryEntity,\n    ThrottlingEntity,\n    CacheManager,\n    Logger,\n    ValidCacheType,\n    ICrypto,\n    AuthorityMetadataEntity,\n    ValidCredentialType\n} from \"@azure/msal-common\";\nimport { Deserializer } from \"./serializer/Deserializer\";\nimport { Serializer } from \"./serializer/Serializer\";\nimport { InMemoryCache, JsonCache, CacheKVStore } from \"./serializer/SerializerTypes\";\n\n/**\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\n * @public\n */\nexport class NodeStorage extends CacheManager {\n    // Cache configuration, either set by user or default values.\n    private logger: Logger;\n    private cache: CacheKVStore = {};\n    private changeEmitters: Array<Function> = [];\n\n    constructor(logger: Logger, clientId: string, cryptoImpl: ICrypto) {\n        super(clientId, cryptoImpl);\n        this.logger = logger;\n    }\n\n    /**\n     * Queue up callbacks\n     * @param func - a callback function for cache change indication\n     */\n    registerChangeEmitter(func: () => void): void {\n        this.changeEmitters.push(func);\n    }\n\n    /**\n     * Invoke the callback when cache changes\n     */\n    emitChange(): void {\n        this.changeEmitters.forEach(func => func.call(null));\n    }\n\n    /**\n     * Converts cacheKVStore to InMemoryCache\n     * @param cache - key value store\n     */\n    cacheToInMemoryCache(cache: CacheKVStore): InMemoryCache {\n        const inMemoryCache: InMemoryCache = {\n            accounts: {},\n            idTokens: {},\n            accessTokens: {},\n            refreshTokens: {},\n            appMetadata: {},\n        };\n\n        for (const key in cache) {\n            if (cache[key as string] instanceof AccountEntity) {\n                inMemoryCache.accounts[key] = cache[key] as AccountEntity;\n            } else if (cache[key] instanceof IdTokenEntity) {\n                inMemoryCache.idTokens[key] = cache[key] as IdTokenEntity;\n            } else if (cache[key] instanceof AccessTokenEntity) {\n                inMemoryCache.accessTokens[key] = cache[key] as AccessTokenEntity;\n            } else if (cache[key] instanceof RefreshTokenEntity) {\n                inMemoryCache.refreshTokens[key] = cache[key] as RefreshTokenEntity;\n            } else if (cache[key] instanceof AppMetadataEntity) {\n                inMemoryCache.appMetadata[key] = cache[key] as AppMetadataEntity;\n            } else {\n                continue;\n            }\n        }\n\n        return inMemoryCache;\n    }\n\n    /**\n     * converts inMemoryCache to CacheKVStore\n     * @param inMemoryCache - kvstore map for inmemory\n     */\n    inMemoryCacheToCache(inMemoryCache: InMemoryCache): CacheKVStore {\n\n        // convert in memory cache to a flat Key-Value map\n        let cache = this.getCache();\n\n        cache = {\n            ...cache,\n            ...inMemoryCache.accounts,\n            ...inMemoryCache.idTokens,\n            ...inMemoryCache.accessTokens,\n            ...inMemoryCache.refreshTokens,\n            ...inMemoryCache.appMetadata\n        };\n\n        // convert in memory cache to a flat Key-Value map\n        return cache;\n    }\n\n    /**\n     * gets the current in memory cache for the client\n     */\n    getInMemoryCache(): InMemoryCache {\n        this.logger.trace(\"Getting in-memory cache\");\n\n        // convert the cache key value store to inMemoryCache\n        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());\n        return inMemoryCache;\n    }\n\n    /**\n     * sets the current in memory cache for the client\n     * @param inMemoryCache - key value map in memory\n     */\n    setInMemoryCache(inMemoryCache: InMemoryCache): void{\n        this.logger.trace(\"Setting in-memory cache\");\n\n        // convert and append the inMemoryCache to cacheKVStore\n        const cache = this.inMemoryCacheToCache(inMemoryCache);\n        this.setCache(cache);\n\n        this.emitChange();\n    }\n\n    /**\n     * get the current cache key-value store\n     */\n    getCache(): CacheKVStore {\n        this.logger.trace(\"Getting cache key-value store\");\n        return this.cache;\n    }\n\n    /**\n     * sets the current cache (key value store)\n     * @param cacheMap - key value map\n     */\n    setCache(cache: CacheKVStore): void {\n        this.logger.trace(\"Setting cache key value store\");\n        this.cache = cache;\n\n        // mark change in cache\n        this.emitChange();\n    }\n\n    /**\n     * Gets cache item with given key.\n     * @param key - lookup key for the cache entry\n     */\n    getItem(key: string): ValidCacheType {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read cache\n        const cache = this.getCache();\n        return cache[key];\n    }\n\n    /**\n     * Gets cache item with given key-value\n     * @param key - lookup key for the cache entry\n     * @param value - value of the cache entry\n     */\n    setItem(key: string, value: ValidCacheType): void {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read cache\n        const cache = this.getCache();\n        cache[key] = value;\n\n        // write to cache\n        this.setCache(cache);\n    }\n\n    /**\n     * fetch the account entity\n     * @param accountKey - lookup key to fetch cache type AccountEntity\n     */\n    getAccount(accountKey: string): AccountEntity | null {\n        const account = this.getItem(accountKey) as AccountEntity;\n        if (AccountEntity.isAccountEntity(account)) {\n            return account;\n        }\n        return null;\n    }\n\n    /**\n     * set account entity\n     * @param account - cache value to be set of type AccountEntity\n     */\n    setAccount(account: AccountEntity): void {\n        const accountKey = account.generateAccountKey();\n        this.setItem(accountKey, account);\n    }\n\n    /**\n     * fetch the idToken credential\n     * @param idTokenKey - lookup key to fetch cache type IdTokenEntity\n     */\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\n        const idToken = this.getItem(idTokenKey) as IdTokenEntity;\n        if (IdTokenEntity.isIdTokenEntity(idToken)) {\n            return idToken;\n        }\n        return null;\n    }\n\n    /**\n     * set idToken credential\n     * @param idToken - cache value to be set of type IdTokenEntity\n     */\n    setIdTokenCredential(idToken: IdTokenEntity): void {\n        const idTokenKey = idToken.generateCredentialKey();\n        this.setItem(idTokenKey, idToken);\n    }\n\n    /**\n     * fetch the accessToken credential\n     * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity\n     */\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\n        const accessToken = this.getItem(accessTokenKey) as AccessTokenEntity;\n        if (AccessTokenEntity.isAccessTokenEntity(accessToken)) {\n            return accessToken;\n        }\n        return null;\n    }\n\n    /**\n     * set accessToken credential\n     * @param accessToken -  cache value to be set of type AccessTokenEntity\n     */\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\n        const accessTokenKey = accessToken.generateCredentialKey();\n        this.setItem(accessTokenKey, accessToken);\n    }\n\n    /**\n     * fetch the refreshToken credential\n     * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity\n     */\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\n        const refreshToken = this.getItem(refreshTokenKey) as RefreshTokenEntity;\n        if (RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {\n            return refreshToken as RefreshTokenEntity;\n        }\n        return null;\n    }\n\n    /**\n     * set refreshToken credential\n     * @param refreshToken - cache value to be set of type RefreshTokenEntity\n     */\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\n        const refreshTokenKey = refreshToken.generateCredentialKey();\n        this.setItem(refreshTokenKey, refreshToken);\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const appMetadata: AppMetadataEntity = this.getItem(appMetadataKey) as AppMetadataEntity;\n        if (AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {\n            return appMetadata;\n        }\n        return null;\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata - cache value to be set of type AppMetadataEntity\n     */\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\n        this.setItem(appMetadataKey, appMetadata);\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity\n     */\n    getServerTelemetry(serverTelemetrykey: string): ServerTelemetryEntity | null {\n        const serverTelemetryEntity: ServerTelemetryEntity = this.getItem(serverTelemetrykey) as ServerTelemetryEntity;\n        if (serverTelemetryEntity && ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {\n            return serverTelemetryEntity;\n        }\n        return null;\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity\n     * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity\n     */\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\n        this.setItem(serverTelemetryKey, serverTelemetry);\n    }\n\n    /**\n     * fetch authority metadata entity from the platform cache\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\n     */\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\n        const authorityMetadataEntity: AuthorityMetadataEntity = this.getItem(key) as AuthorityMetadataEntity;\n        if (authorityMetadataEntity && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {\n            return authorityMetadataEntity;\n        }\n        return null;\n    }\n\n    /**\n     * Get all authority metadata keys\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        return this.getKeys().filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * set authority metadata entity to the platform cache\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\n     * @param metadata - cache value to be set of type AuthorityMetadataEntity\n     */\n    setAuthorityMetadata(key: string, metadata: AuthorityMetadataEntity): void {\n        this.setItem(key, metadata);\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const throttlingCache: ThrottlingEntity = this.getItem(throttlingCacheKey) as ThrottlingEntity;\n        if (throttlingCache && ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {\n            return throttlingCache;\n        }\n        return null;\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\n     * @param throttlingCache - cache value to be set of type ThrottlingEntity\n     */\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\n        this.setItem(throttlingCacheKey, throttlingCache);\n    }\n\n    /**\n     * Removes the cache item from memory with the given key.\n     * @param key - lookup key to remove a cache entity\n     * @param inMemory - key value map of the cache\n     */\n    removeItem(key: string): boolean {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read inMemoryCache\n        let result: boolean = false;\n        const cache = this.getCache();\n\n        if (!!cache[key]) {\n            delete cache[key];\n            result = true;\n        }\n\n        // write to the cache after removal\n        if (result) {\n            this.setCache(cache);\n            this.emitChange();\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether key is in cache.\n     * @param key - look up key for a cache entity\n     */\n    containsKey(key: string): boolean {\n        return this.getKeys().includes(key);\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        this.logger.trace(\"Retrieving all cache keys\");\n\n        // read cache\n        const cache = this.getCache();\n        return [ ...Object.keys(cache)];\n    }\n\n    /**\n     * Clears all cache entries created by MSAL (except tokens).\n     */\n    async clear(): Promise<void> {\n        this.logger.trace(\"Clearing cache entries created by MSAL\");\n\n        // read inMemoryCache\n        const cacheKeys = this.getKeys();\n\n        // delete each element\n        cacheKeys.forEach(key => {\n            this.removeItem(key);\n        });\n        this.emitChange();\n    }\n\n    /**\n     * Initialize in memory cache from an exisiting cache vault\n     * @param cache - blob formatted cache (JSON)\n     */\n    static generateInMemoryCache(cache: string): InMemoryCache {\n        return Deserializer.deserializeAllCache(\n            Deserializer.deserializeJSONBlob(cache)\n        );\n    }\n\n    /**\n     * retrieves the final JSON\n     * @param inMemoryCache - itemised cache read from the JSON\n     */\n    static generateJsonCache(inMemoryCache: InMemoryCache): JsonCache {\n        return Serializer.serializeAllCache(inMemoryCache);\n    }\n\n    /**\n     * Updates a credential's cache key if the current cache key is outdated\n     */\n    updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string {\n        const updatedCacheKey = credential.generateCredentialKey();\n\n        if (currentCacheKey !== updatedCacheKey) {\n            const cacheItem = this.getItem(currentCacheKey);\n            if (cacheItem) {\n                this.removeItem(currentCacheKey);\n                this.setItem(updatedCacheKey, cacheItem);\n                this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\n                return updatedCacheKey;\n            } else {\n                this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\n            }\n        }\n\n        return currentCacheKey;\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { NodeStorage } from \"./NodeStorage\";\nimport { StringUtils, AccountEntity, AccountInfo, Logger, ISerializableTokenCache, ICachePlugin, TokenCacheContext } from \"@azure/msal-common\";\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedIdTokenEntity, SerializedAppMetadataEntity, CacheKVStore } from \"./serializer/SerializerTypes\";\nimport { Deserializer } from \"./serializer/Deserializer\";\nimport { Serializer } from \"./serializer/Serializer\";\nimport { ITokenCache } from \"./ITokenCache\";\n\nconst defaultSerializedCache: JsonCache = {\n    Account: {},\n    IdToken: {},\n    AccessToken: {},\n    RefreshToken: {},\n    AppMetadata: {},\n};\n\n/**\n * In-memory token cache manager\n * @public\n */\nexport class TokenCache implements ISerializableTokenCache, ITokenCache {\n\n    private storage: NodeStorage;\n    private cacheHasChanged: boolean;\n    private cacheSnapshot: string;\n    private readonly persistence: ICachePlugin;\n    private logger: Logger;\n\n    constructor(storage: NodeStorage, logger: Logger, cachePlugin?: ICachePlugin) {\n        this.cacheHasChanged = false;\n        this.storage = storage;\n        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\n        if (cachePlugin) {\n            this.persistence = cachePlugin;\n        }\n        this.logger = logger;\n    }\n\n    /**\n     * Set to true if cache state has changed since last time serialize or writeToPersistence was called\n     */\n    hasChanged(): boolean {\n        return this.cacheHasChanged;\n    }\n\n    /**\n     * Serializes in memory cache to JSON\n     */\n    serialize(): string {\n        this.logger.trace(\"Serializing in-memory cache\");\n        let finalState = Serializer.serializeAllCache(\n            this.storage.getInMemoryCache() as InMemoryCache\n        );\n\n        // if cacheSnapshot not null or empty, merge\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\n            this.logger.trace(\"Reading cache snapshot from disk\");\n            finalState = this.mergeState(\n                JSON.parse(this.cacheSnapshot),\n                finalState\n            );\n        } else {\n            this.logger.trace(\"No cache snapshot to merge\");\n        }\n        this.cacheHasChanged = false;\n\n        return JSON.stringify(finalState);\n    }\n\n    /**\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\n     * @param cache - blob formatted cache\n     */\n    deserialize(cache: string): void {\n        this.logger.trace(\"Deserializing JSON to in-memory cache\");\n        this.cacheSnapshot = cache;\n\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\n            this.logger.trace(\"Reading cache snapshot from disk\");\n            const deserializedCache = Deserializer.deserializeAllCache(\n                this.overlayDefaults(JSON.parse(this.cacheSnapshot))\n            );\n            this.storage.setInMemoryCache(deserializedCache);\n        } else {\n            this.logger.trace(\"No cache snapshot to deserialize\");\n        }\n    }\n\n    /**\n     * Fetches the cache key-value map\n     */\n    getKVStore(): CacheKVStore {\n        return this.storage.getCache();\n    }\n\n    /**\n     * API that retrieves all accounts currently in cache to the user\n     */\n    async getAllAccounts(): Promise<AccountInfo[]> {\n\n        this.logger.trace(\"getAllAccounts called\");\n        let cacheContext;\n        try {\n            if (this.persistence) {\n                cacheContext = new TokenCacheContext(this, false);\n                await this.persistence.beforeCacheAccess(cacheContext);\n            }\n            return this.storage.getAllAccounts();\n        } finally {\n            if (this.persistence && cacheContext) {\n                await this.persistence.afterCacheAccess(cacheContext);\n            }\n        }\n    }\n\n    /**\n     * Returns the signed in account matching homeAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param homeAccountId - unique identifier for an account (uid.utid)\n     */\n    async getAccountByHomeId(homeAccountId: string): Promise<AccountInfo | null> {\n        const allAccounts = await this.getAllAccounts();\n        if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {\n            return allAccounts.filter(accountObj => accountObj.homeAccountId === homeAccountId)[0] || null;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the signed in account matching localAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)\n     */\n    async getAccountByLocalId(localAccountId: string): Promise<AccountInfo | null> {\n        const allAccounts = await this.getAllAccounts();\n        if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {\n            return allAccounts.filter(accountObj => accountObj.localAccountId === localAccountId)[0] || null;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * API to remove a specific account and the relevant data from cache\n     * @param account - AccountInfo passed by the user\n     */\n    async removeAccount(account: AccountInfo): Promise<void> {\n        this.logger.trace(\"removeAccount called\");\n        let cacheContext;\n        try {\n            if (this.persistence) {\n                cacheContext = new TokenCacheContext(this, true);\n                await this.persistence.beforeCacheAccess(cacheContext);\n            }\n            await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));\n        } finally {\n            if (this.persistence && cacheContext) {\n                await this.persistence.afterCacheAccess(cacheContext);\n            }\n        }\n    }\n\n    /**\n     * Called when the cache has changed state.\n     */\n    private handleChangeEvent() {\n        this.cacheHasChanged = true;\n    }\n\n    /**\n     * Merge in memory cache with the cache snapshot.\n     * @param oldState - cache before changes\n     * @param currentState - current cache state in the library\n     */\n    private mergeState(oldState: JsonCache, currentState: JsonCache): JsonCache {\n        this.logger.trace(\"Merging in-memory cache with cache snapshot\");\n        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);\n        return this.mergeUpdates(stateAfterRemoval, currentState);\n    }\n\n    /**\n     * Deep update of oldState based on newState values\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeUpdates(oldState: object, newState: object): JsonCache {\n        Object.keys(newState).forEach((newKey: string) => {\n            const newValue = newState[newKey];\n\n            // if oldState does not contain value but newValue does, add it\n            if (!oldState.hasOwnProperty(newKey)) {\n                if (newValue !== null) {\n                    oldState[newKey] = newValue;\n                }\n            } else {\n                // both oldState and newState contain the key, do deep update\n                const newValueNotNull = newValue !== null;\n                const newValueIsObject = typeof newValue === \"object\";\n                const newValueIsNotArray = !Array.isArray(newValue);\n                const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== \"undefined\" && oldState[newKey] !== null;\n\n                if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {\n                    this.mergeUpdates(oldState[newKey], newValue);\n                } else {\n                    oldState[newKey] = newValue;\n                }\n            }\n        });\n\n        return oldState as JsonCache;\n    }\n\n    /**\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\n     * oldState that are not recognized, they are left untouched.\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeRemovals(oldState: JsonCache, newState: JsonCache): JsonCache {\n        this.logger.trace(\"Remove updated entries in cache\");\n        const accounts = oldState.Account ? this.mergeRemovalsDict<SerializedAccountEntity>(oldState.Account, newState.Account) : oldState.Account;\n        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict<SerializedAccessTokenEntity>(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;\n        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict<SerializedRefreshTokenEntity>(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;\n        const idTokens = oldState.IdToken ? this.mergeRemovalsDict<SerializedIdTokenEntity>(oldState.IdToken, newState.IdToken) : oldState.IdToken;\n        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict<SerializedAppMetadataEntity>(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;\n\n        return {\n            ...oldState,\n            Account: accounts,\n            AccessToken: accessTokens,\n            RefreshToken: refreshTokens,\n            IdToken: idTokens,\n            AppMetadata: appMetadata\n        };\n    }\n\n    /**\n     * Helper to merge new cache with the old one\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeRemovalsDict<T>(oldState: Record<string, T>, newState?: Record<string, T>): Record<string, T> {\n        const finalState = { ...oldState };\n        Object.keys(oldState).forEach((oldKey) => {\n            if (!newState || !(newState.hasOwnProperty(oldKey))) {\n                delete finalState[oldKey];\n            }\n        });\n        return finalState;\n    }\n\n    /**\n     * Helper to overlay as a part of cache merge\n     * @param passedInCache - cache read from the blob\n     */\n    private overlayDefaults(passedInCache: JsonCache): JsonCache {\n        this.logger.trace(\"Overlaying input cache with the default cache\");\n        return {\n            Account: {\n                ...defaultSerializedCache.Account,\n                ...passedInCache.Account,\n            },\n            IdToken: {\n                ...defaultSerializedCache.IdToken,\n                ...passedInCache.IdToken,\n            },\n            AccessToken: {\n                ...defaultSerializedCache.AccessToken,\n                ...passedInCache.AccessToken,\n            },\n            RefreshToken: {\n                ...defaultSerializedCache.RefreshToken,\n                ...passedInCache.RefreshToken,\n            },\n            AppMetadata: {\n                ...defaultSerializedCache.AppMetadata,\n                ...passedInCache.AppMetadata,\n            },\n        };\n    }\n}\n","/* eslint-disable header/header */\nexport const name = \"@azure/msal-node\";\nexport const version = \"1.14.4\";\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthError } from \"@azure/msal-common\";\n\n/**\n * NodeAuthErrorMessage class containing string constants used by error codes and messages.\n */\nexport const NodeAuthErrorMessage = {\n    invalidLoopbackAddressType: {\n        code: \"invalid_loopback_server_address_type\",\n        desc: \"Loopback server address is not type string. This is unexpected.\"\n    },\n    unableToLoadRedirectUri: {\n        code: \"unable_to_load_redirectUrl\",\n        desc: \"Loopback server callback was invoked without a url. This is unexpected.\"\n    },\n    noAuthCodeInResponse: {\n        code: \"no_auth_code_in_response\",\n        desc: \"No auth code found in the server response. Please check your network trace to determine what happened.\"\n    },\n    noLoopbackServerExists: {\n        code: \"no_loopback_server_exists\",\n        desc: \"No loopback server exists yet.\"\n    },\n    loopbackServerAlreadyExists: {\n        code: \"loopback_server_already_exists\",\n        desc: \"Loopback server already exists. Cannot create another.\"\n    },\n    loopbackServerTimeout: {\n        code: \"loopback_server_timeout\",\n        desc: \"Timed out waiting for auth code listener to be registered.\"\n    },\n    stateNotFoundError: {\n        code: \"state_not_found\",\n        desc: \"State not found. Please verify that the request originated from msal.\"\n    },\n};\n\nexport class NodeAuthError extends AuthError {\n    constructor(errorCode: string, errorMessage?: string) {\n        super(errorCode, errorMessage);\n        this.name = \"NodeAuthError\";\n    }\n\n    /**\n     * Creates an error thrown if loopback server address is of type string.\n     */\n    static createInvalidLoopbackAddressTypeError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code,\n            `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if the loopback server is unable to get a url.\n     */\n    static createUnableToLoadRedirectUrlError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code,\n            `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if the server response does not contain an auth code.\n     */\n    static createNoAuthCodeInResponseError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code,\n            `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if the loopback server has not been spun up yet.\n     */\n    static createNoLoopbackServerExistsError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code,\n            `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if a loopback server already exists when attempting to create another one.\n     */\n    static createLoopbackServerAlreadyExistsError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code,\n            `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);\n    }\n\n    /**\n     * Creates an error thrown if the loopback server times out registering the auth code listener.\n     */\n    static createLoopbackServerTimeoutError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code,\n            `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);\n    }\n\n    /**\n     * Creates an error thrown when the state is not present.\n     */\n    static createStateNotFoundError(): NodeAuthError {\n        return new NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodeClient,\n    ClientConfiguration,\n    RefreshTokenClient,\n    AuthenticationResult,\n    Authority,\n    AuthorityFactory,\n    BaseAuthRequest,\n    SilentFlowClient,\n    Logger,\n    ServerTelemetryManager,\n    ServerTelemetryRequest,\n    CommonSilentFlowRequest,\n    CommonRefreshTokenRequest,\n    CommonAuthorizationCodeRequest,\n    CommonAuthorizationUrlRequest,\n    CommonUsernamePasswordRequest,\n    UsernamePasswordClient,\n    AuthenticationScheme,\n    ResponseMode,\n    AuthorityOptions,\n    OIDC_DEFAULT_SCOPES,\n    AzureRegionConfiguration,\n    AuthError,\n    AzureCloudOptions,\n    AuthorizationCodePayload,\n    StringUtils,\n    ClientAuthError,\n    Constants,\n} from \"@azure/msal-common\";\nimport { Configuration, buildAppConfiguration, NodeConfiguration } from \"../config/Configuration\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\nimport { NodeStorage } from \"../cache/NodeStorage\";\nimport { Constants as NodeConstants, ApiId } from \"../utils/Constants\";\nimport { TokenCache } from \"../cache/TokenCache\";\nimport { ClientAssertion } from \"./ClientAssertion\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\nimport { RefreshTokenRequest } from \"../request/RefreshTokenRequest\";\nimport { SilentFlowRequest } from \"../request/SilentFlowRequest\";\nimport { version, name } from \"../packageMetadata\";\nimport { UsernamePasswordRequest } from \"../request/UsernamePasswordRequest\";\nimport { NodeAuthError } from \"../error/NodeAuthError\";\n\n/**\n * Base abstract class for all ClientApplications - public and confidential\n * @public\n */\nexport abstract class ClientApplication {\n\n    protected readonly cryptoProvider: CryptoProvider;\n    private tokenCache: TokenCache;\n\n    /**\n     * Platform storage object\n     */\n    protected storage: NodeStorage;\n    /**\n     * Logger object to log the application flow\n     */\n    protected logger: Logger;\n    /**\n     * Platform configuration initialized by the application\n     */\n    protected config: NodeConfiguration;\n    /**\n     * Client assertion passed by the user for confidential client flows\n     */\n    protected clientAssertion: ClientAssertion;\n    /**\n     * Client secret passed by the user for confidential client flows\n     */\n    protected clientSecret: string;\n\n    /**\n     * Constructor for the ClientApplication\n     */\n    protected constructor(configuration: Configuration) {\n        this.config = buildAppConfiguration(configuration);\n        this.cryptoProvider = new CryptoProvider();\n        this.logger = new Logger(this.config.system.loggerOptions, name, version);\n        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);\n        this.tokenCache = new TokenCache(\n            this.storage,\n            this.logger,\n            this.config.cache.cachePlugin\n        );\n    }\n\n    /**\n     * Creates the URL of the authorization request, letting the user input credentials and consent to the\n     * application. The URL targets the /authorize endpoint of the authority configured in the\n     * application object.\n     *\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n     * `acquireTokenByCode(AuthorizationCodeRequest)`.\n     */\n    async getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string> {\n        this.logger.info(\"getAuthCodeUrl called\", request.correlationId);\n        const validRequest: CommonAuthorizationUrlRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            responseMode: request.responseMode || ResponseMode.QUERY,\n            authenticationScheme: AuthenticationScheme.BEARER\n        };\n\n        const authClientConfig = await this.buildOauthClientConfiguration(\n            validRequest.authority,\n            validRequest.correlationId,\n            undefined,\n            undefined,\n            request.azureCloudOptions\n        );\n        const authorizationCodeClient = new AuthorizationCodeClient(\n            authClientConfig\n        );\n        this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\n        return authorizationCodeClient.getAuthCodeUrl(validRequest);\n    }\n\n    /**\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\n     * Authorization Code flow.\n     *\n     * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\n     * AuthorizationCodeRequest are the same.\n     */\n    async acquireTokenByCode(request: AuthorizationCodeRequest, authCodePayLoad?: AuthorizationCodePayload): Promise<AuthenticationResult> {\n        this.logger.info(\"acquireTokenByCode called\");\n        if (request.state && authCodePayLoad){\n            this.logger.info(\"acquireTokenByCode - validating state\");\n            this.validateState(request.state, authCodePayLoad.state || \"\");\n            // eslint-disable-next-line no-param-reassign\n            authCodePayLoad= {...authCodePayLoad, state: \"\"};\n        }\n        const validRequest: CommonAuthorizationCodeRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            authenticationScheme: AuthenticationScheme.BEARER\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);\n        try {\n            const authClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const authorizationCodeClient = new AuthorizationCodeClient(\n                authClientConfig\n            );\n            this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\n            return authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\n     *\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is\n     * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will\n     * handle the caching and refreshing of tokens automatically.\n     */\n    async acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByRefreshToken called\", request.correlationId);\n        const validRequest: CommonRefreshTokenRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            authenticationScheme: AuthenticationScheme.BEARER\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);\n        try {\n            const refreshTokenClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const refreshTokenClient = new RefreshTokenClient(\n                refreshTokenClientConfig\n            );\n            this.logger.verbose(\"Refresh token client created\", validRequest.correlationId);\n            return refreshTokenClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token silently when a user specifies the account the token is requested for.\n     *\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\n     * There is also an optional \"forceRefresh\" boolean the user can send to bypass the cache for access_token and id_token.\n     * In case the refresh_token is expired or not found, an error is thrown\n     * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).\n     */\n    async acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult | null> {\n        const validRequest: CommonSilentFlowRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            forceRefresh: request.forceRefresh || false\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);\n        try {\n            const silentFlowClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const silentFlowClient = new SilentFlowClient(\n                silentFlowClientConfig\n            );\n            this.logger.verbose(\"Silent flow client created\", validRequest.correlationId);\n            return silentFlowClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires tokens with password grant by exchanging client applications username and password for credentials\n     *\n     * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.\n     * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4\n     * Microsoft's documentation and recommendations are at:\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword\n     *\n     * @param request - UsenamePasswordRequest\n     */\n    async acquireTokenByUsernamePassword(request: UsernamePasswordRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByUsernamePassword called\", request.correlationId);\n        const validRequest: CommonUsernamePasswordRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request)\n        };\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);\n        try {\n            const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);\n            this.logger.verbose(\"Username password client created\", validRequest.correlationId);\n            return usernamePasswordClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Gets the token cache for the application.\n     */\n    getTokenCache(): TokenCache {\n        this.logger.info(\"getTokenCache called\");\n        return this.tokenCache;\n    }\n\n    /**\n     * Validates OIDC state by comparing the user cached state with the state received from the server.\n     * \n     * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against\n     * CSRF attacks.\n     * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.\n     * @param state\n     * @param cachedState\n     */\n    protected validateState(state: string, cachedState: string): void {\n        if(!state) {\n            throw NodeAuthError.createStateNotFoundError();\n        }\n\n        if(state !== cachedState) {\n            throw ClientAuthError.createStateMismatchError();\n        }\n    }\n\n    /**\n     * Returns the logger instance\n     */\n    getLogger(): Logger {\n        return this.logger;\n    }\n\n    /**\n     * Replaces the default logger set in configurations with new Logger with new configurations\n     * @param logger - Logger instance\n     */\n    setLogger(logger: Logger): void {\n        this.logger = logger;\n    }\n\n    /**\n     * Builds the common configuration to be passed to the common component based on the platform configurarion\n     * @param authority - user passed authority in configuration\n     * @param serverTelemetryManager - initializes servertelemetry if passed\n     */\n    protected async buildOauthClientConfiguration(\n        authority: string,\n        requestCorrelationId?: string, \n        serverTelemetryManager?: ServerTelemetryManager,\n        azureRegionConfiguration?: AzureRegionConfiguration, \n        azureCloudOptions?: AzureCloudOptions): Promise<ClientConfiguration> {\n        \n        this.logger.verbose(\"buildOauthClientConfiguration called\", requestCorrelationId);\n\n        // precedence - azureCloudInstance + tenant >> authority and request  >> config\n        const userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions;\n\n        // using null assertion operator as we ensure that all config values have default values in buildConfiguration()\n        this.logger.verbose(`building oauth client configuration with the authority: ${authority}`, requestCorrelationId);\n        const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId, userAzureCloudOptions);\n\n        serverTelemetryManager?.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);\n\n        const clientConfiguration: ClientConfiguration = {\n            authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities\n            },\n            systemOptions: {\n                proxyUrl: this.config.system.proxyUrl,\n            },\n            loggerOptions: {\n                logLevel: this.config.system.loggerOptions.logLevel,\n                loggerCallback: this.config.system.loggerOptions\n                    .loggerCallback,\n                piiLoggingEnabled: this.config.system.loggerOptions\n                    .piiLoggingEnabled,\n                correlationId: requestCorrelationId\n            },\n            cryptoInterface: this.cryptoProvider,\n            networkInterface: this.config.system.networkClient,\n            storageInterface: this.storage,\n            serverTelemetryManager: serverTelemetryManager,\n            clientCredentials: {\n                clientSecret: this.clientSecret,\n                clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : undefined,\n            },\n            libraryInfo: {\n                sku: NodeConstants.MSAL_SKU,\n                version: version,\n                cpu: process.arch || Constants.EMPTY_STRING,\n                os: process.platform || Constants.EMPTY_STRING,\n            },\n            telemetry: this.config.telemetry,\n            persistencePlugin: this.config.cache.cachePlugin,\n            serializableCache: this.tokenCache            \n        };\n\n        return clientConfiguration;\n    }\n\n    private getClientAssertion(authority: Authority): { assertion: string, assertionType: string } {\n        return {\n            assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),\n            assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE\n        };\n    }\n\n    /**\n     * Generates a request with the default scopes & generates a correlationId.\n     * @param authRequest - BaseAuthRequest for initialization\n     */\n    protected async initializeBaseRequest(authRequest: Partial<BaseAuthRequest>): Promise<BaseAuthRequest> {\n        this.logger.verbose(\"initializeRequestScopes called\", authRequest.correlationId);\n        // Default authenticationScheme to Bearer, log that POP isn't supported yet\n        if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {\n            this.logger.verbose(\"Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request\", authRequest.correlationId);\n        }\n\n        authRequest.authenticationScheme = AuthenticationScheme.BEARER;\n\n        // Set requested claims hash if claims were requested\n        if (authRequest.claims && !StringUtils.isEmpty(authRequest.claims)) {\n            authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);\n        }\n\n        return {\n            ...authRequest,\n            scopes: [...((authRequest && authRequest.scopes) || []), ...OIDC_DEFAULT_SCOPES],\n            correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),\n            authority: authRequest.authority || this.config.auth.authority\n        };\n    }\n\n    /**\n     * Initializes the server telemetry payload\n     * @param apiId - Id for a specific request\n     * @param correlationId - GUID\n     * @param forceRefresh - boolean to indicate network call\n     */\n    protected initializeServerTelemetryManager(apiId: number, correlationId: string, forceRefresh?: boolean): ServerTelemetryManager {\n        const telemetryPayload: ServerTelemetryRequest = {\n            clientId: this.config.auth.clientId,\n            correlationId: correlationId,\n            apiId: apiId,\n            forceRefresh: forceRefresh || false\n        };\n\n        return new ServerTelemetryManager(telemetryPayload, this.storage);\n    }\n\n    /**\n     * Create authority instance. If authority not passed in request, default to authority set on the application\n     * object. If no authority set in application object, then default to common authority.\n     * @param authorityString - authority from user configuration\n     */\n    private async createAuthority(authorityString: string, azureRegionConfiguration?: AzureRegionConfiguration, requestCorrelationId?: string, azureCloudOptions?: AzureCloudOptions): Promise<Authority> {\n        this.logger.verbose(\"createAuthority called\", requestCorrelationId);\n\n        // build authority string based on auth params - azureCloudInstance is prioritized if provided\n        const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions);\n\n        const authorityOptions: AuthorityOptions = {\n            protocolMode: this.config.auth.protocolMode,\n            knownAuthorities: this.config.auth.knownAuthorities,\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n            authorityMetadata: this.config.auth.authorityMetadata,\n            azureRegionConfiguration,\n            skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache,\n        };\n\n        return await AuthorityFactory.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger, this.config.system.proxyUrl);\n    }\n\n    /**\n     * Clear the cache\n     */\n    clearCache(): void {\n        this.storage.clear();\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants as CommonConstants, ServerAuthorizationCodeResponse, UrlString } from \"@azure/msal-common\";\nimport { createServer, IncomingMessage, Server, ServerResponse } from \"http\";\nimport { NodeAuthError } from \"../error/NodeAuthError\";\nimport { Constants, HttpStatus, LOOPBACK_SERVER_CONSTANTS } from \"../utils/Constants\";\n\nexport class LoopbackClient {\n    private server: Server;\n\n    /**\n     * Spins up a loopback server which returns the server response when the localhost redirectUri is hit\n     * @param successTemplate \n     * @param errorTemplate \n     * @returns \n     */\n    async listenForAuthCode(successTemplate?: string, errorTemplate?: string): Promise<ServerAuthorizationCodeResponse> {\n        if (!!this.server) {\n            throw NodeAuthError.createLoopbackServerAlreadyExistsError();\n        }\n\n        const authCodeListener = new Promise<ServerAuthorizationCodeResponse>((resolve, reject) => {\n            this.server = createServer(async (req: IncomingMessage, res: ServerResponse) => {\n                const url = req.url;\n                if (!url) {\n                    res.end(errorTemplate || \"Error occurred loading redirectUrl\");\n                    reject(NodeAuthError.createUnableToLoadRedirectUrlError());\n                    return;\n                } else if (url === CommonConstants.FORWARD_SLASH) {\n                    res.end(successTemplate || \"Auth code was successfully acquired. You can close this window now.\");\n                    return;\n                }\n    \n                const authCodeResponse = UrlString.getDeserializedQueryString(url);\n                if (authCodeResponse.code) {\n                    const redirectUri = await this.getRedirectUri();\n                    res.writeHead(HttpStatus.REDIRECT, { location: redirectUri }); // Prevent auth code from being saved in the browser history\n                    res.end();\n                }\n                resolve(authCodeResponse);\n            });\n            this.server.listen(0); // Listen on any available port\n        });\n\n        // Wait for server to be listening\n        await new Promise<void>((resolve) => {\n            let ticks = 0;\n            const id = setInterval(() => {\n                if ((LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS / LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS) < ticks) {\n                    throw NodeAuthError.createLoopbackServerTimeoutError();\n                }\n                \n                if (this.server.listening) {\n                    clearInterval(id);\n                    resolve();\n                }\n                ticks++;\n            }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);\n        });\n\n        return authCodeListener;\n    }\n\n    /**\n     * Get the port that the loopback server is running on\n     * @returns \n     */\n    getRedirectUri(): string {\n        if (!this.server) {\n            throw NodeAuthError.createNoLoopbackServerExistsError();\n        }\n                \n        const address = this.server.address();\n        if (!address || typeof address === \"string\" || !address.port) {\n            this.closeServer();\n            throw NodeAuthError.createInvalidLoopbackAddressTypeError();\n        } \n\n        const port = address && address.port;\n\n        return `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}:${port}`;\n    }\n\n    /**\n     * Close the loopback server\n     */\n    closeServer(): void {\n        if (!!this.server) {\n            this.server.close();\n        }\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ApiId } from \"../utils/Constants\";\nimport {\n    DeviceCodeClient,\n    AuthenticationResult,\n    CommonDeviceCodeRequest,\n    AuthError,\n    ResponseMode,\n    OIDC_DEFAULT_SCOPES,\n    CodeChallengeMethodValues,\n    Constants as CommonConstants,\n    ServerError\n} from \"@azure/msal-common\";\nimport { Configuration } from \"../config/Configuration\";\nimport { ClientApplication } from \"./ClientApplication\";\nimport { IPublicClientApplication } from \"./IPublicClientApplication\";\nimport { DeviceCodeRequest } from \"../request/DeviceCodeRequest\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\nimport { InteractiveRequest } from \"../request/InteractiveRequest\";\nimport { NodeAuthError } from \"../error/NodeAuthError\";\nimport { LoopbackClient } from \"../network/LoopbackClient\";\n\n/**\n * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\n * @public\n */\nexport class PublicClientApplication extends ClientApplication implements IPublicClientApplication {\n    /**\n     * Important attributes in the Configuration object for auth are:\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.\n     * - authority: the authority URL for your application.\n     *\n     * AAD authorities are of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\n     * - If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n     * - If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n     * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n     * - To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n     *\n     * Azure B2C authorities are of the form https://\\{instance\\}/\\{tenant\\}/\\{policy\\}. Each policy is considered\n     * its own authority. You will have to set the all of the knownAuthorities at the time of the client application\n     * construction.\n     *\n     * ADFS authorities are of the form https://\\{instance\\}/adfs.\n     */\n    constructor(configuration: Configuration) {\n        super(configuration);\n    }\n\n    /**\n     * Acquires a token from the authority using OAuth2.0 device code flow.\n     * This flow is designed for devices that do not have access to a browser or have input constraints.\n     * The authorization server issues a DeviceCode object with a verification code, an end-user code,\n     * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be\n     * instructed to use another device to navigate to the verification URI to input credentials.\n     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\n     * until the end-user completes input of credentials.\n     */\n    public async acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByDeviceCode called\", request.correlationId);\n        const validRequest: CommonDeviceCodeRequest = Object.assign(request,  await this.initializeBaseRequest(request));\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);\n        try {\n            const deviceCodeConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\n            this.logger.verbose(\"Device code client created\", validRequest.correlationId);\n            return deviceCodeClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token by requesting an Authorization code then exchanging it for a token.\n     */\n    async acquireTokenInteractive(request: InteractiveRequest): Promise<AuthenticationResult> {\n        const { verifier, challenge } = await this.cryptoProvider.generatePkceCodes();\n        const { openBrowser, successTemplate, errorTemplate, ...remainingProperties } = request;\n\n        const loopbackClient = new LoopbackClient();\n        const authCodeListener = loopbackClient.listenForAuthCode(successTemplate, errorTemplate);\n        const redirectUri = loopbackClient.getRedirectUri();\n\n        const validRequest: AuthorizationUrlRequest = {\n            ...remainingProperties,\n            scopes: request.scopes || OIDC_DEFAULT_SCOPES,\n            redirectUri: redirectUri,\n            responseMode: ResponseMode.QUERY,\n            codeChallenge: challenge, \n            codeChallengeMethod: CodeChallengeMethodValues.S256\n        };\n\n        const authCodeUrl = await this.getAuthCodeUrl(validRequest);\n        await openBrowser(authCodeUrl);\n        const authCodeResponse = await authCodeListener.finally(() => {\n            loopbackClient.closeServer();\n        });\n\n        if (authCodeResponse.error) {\n            throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);\n        } else if (!authCodeResponse.code) {\n            throw NodeAuthError.createNoAuthCodeInResponseError();\n        }\n\n        const clientInfo = authCodeResponse.client_info;\n        const tokenRequest: AuthorizationCodeRequest = {\n            code: authCodeResponse.code,\n            codeVerifier: verifier,\n            clientInfo: clientInfo || CommonConstants.EMPTY_STRING,\n            ...validRequest\n        };\n        return this.acquireTokenByCode(tokenRequest);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { JwtHeader, sign } from \"jsonwebtoken\";\nimport { TimeUtils, ClientAuthError, Constants } from \"@azure/msal-common\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\nimport { JwtConstants } from \"../utils/Constants\";\n\n/**\n * Client assertion of type jwt-bearer used in confidential client flows\n * @public\n */\nexport class ClientAssertion {\n\n    private jwt: string;\n    private privateKey: string;\n    private thumbprint: string;\n    private expirationTime: number;\n    private issuer: string;\n    private jwtAudience: string;\n    private publicCertificate: Array<string>;\n\n    /**\n     * Initialize the ClientAssertion class from the clientAssertion passed by the user\n     * @param assertion - refer https://tools.ietf.org/html/rfc7521\n     */\n    public static fromAssertion(assertion: string): ClientAssertion {\n        const clientAssertion = new ClientAssertion();\n        clientAssertion.jwt = assertion;\n        return clientAssertion;\n    }\n\n    /**\n     * Initialize the ClientAssertion class from the certificate passed by the user\n     * @param thumbprint - identifier of a certificate\n     * @param privateKey - secret key\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\n     */\n    public static fromCertificate(thumbprint: string, privateKey: string, publicCertificate?: string): ClientAssertion {\n        const clientAssertion = new ClientAssertion();\n        clientAssertion.privateKey = privateKey;\n        clientAssertion.thumbprint = thumbprint;\n        if (publicCertificate) {\n            clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);\n        }\n        return clientAssertion;\n    }\n\n    /**\n     * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is\n     * @param cryptoProvider - library's crypto helper\n     * @param issuer - iss claim\n     * @param jwtAudience - aud claim\n     */\n    public getJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\n        // if assertion was created from certificate, check if jwt is expired and create new one.\n        if (this.privateKey && this.thumbprint) {\n\n            if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {\n                return this.jwt;\n            }\n\n            return this.createJwt(cryptoProvider, issuer, jwtAudience);\n        }\n\n        /*\n         * if assertion was created by caller, then we just append it. It is up to the caller to\n         * ensure that it contains necessary claims and that it is not expired.\n         */\n        if (this.jwt) {\n            return this.jwt;\n        }\n\n        throw ClientAuthError.createInvalidAssertionError();\n    }\n\n    /**\n     * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3\n     */\n    private createJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\n\n        this.issuer = issuer;\n        this.jwtAudience = jwtAudience;\n        const issuedAt = TimeUtils.nowSeconds();\n        this.expirationTime = issuedAt + 600;\n\n        const header: JwtHeader = {\n            alg: JwtConstants.RSA_256,\n            x5t: EncodingUtils.base64EncodeUrl(this.thumbprint, \"hex\")\n        };\n\n        if (this.publicCertificate) {\n            Object.assign(header, {\n                x5c: this.publicCertificate\n            } as Partial<JwtHeader>);\n        }\n\n        const payload = {\n            [JwtConstants.AUDIENCE]: this.jwtAudience,\n            [JwtConstants.EXPIRATION_TIME]: this.expirationTime,\n            [JwtConstants.ISSUER]: this.issuer,\n            [JwtConstants.SUBJECT]: this.issuer,\n            [JwtConstants.NOT_BEFORE]: issuedAt,\n            [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()\n        };\n\n        this.jwt = sign(payload, this.privateKey, { header });\n        return this.jwt;\n    }\n\n    /**\n     * Utility API to check expiration\n     */\n    private isExpired(): boolean {\n        return this.expirationTime < TimeUtils.nowSeconds();\n    }\n\n    /**\n     * Extracts the raw certs from a given certificate string and returns them in an array.\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\n     */\n    public static parseCertificate(publicCertificate: string): Array<string> {\n        /**\n         * This is regex to identify the certs in a given certificate string.\n         * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.\n         * The information in parens \"(.+?)\" is the capture group to represent the cert we want isolated.\n         * \".\" means any string character, \"+\" means match 1 or more times, and \"?\" means the shortest match.\n         * The \"g\" at the end of the regex means search the string globally, and the \"s\" enables the \".\" to match newlines.\n         */\n        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\\r*\\n(.+?)\\r*\\n-----END CERTIFICATE-----/gs;\n        const certs: string[] = [];\n\n        let matches;\n        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {\n            // matches[1] represents the first parens capture group in the regex.\n            certs.push(matches[1].replace(/\\r*\\n/g, Constants.EMPTY_STRING));\n        }\n\n        return certs;\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ClientApplication } from \"./ClientApplication\";\nimport { Configuration } from \"../config/Configuration\";\nimport { ClientAssertion } from \"./ClientAssertion\";\nimport { Constants as NodeConstants, ApiId, REGION_ENVIRONMENT_VARIABLE } from \"../utils/Constants\";\nimport {\n    ClientCredentialClient,\n    OnBehalfOfClient,\n    CommonClientCredentialRequest,\n    CommonOnBehalfOfRequest,\n    AuthenticationResult,\n    StringUtils,\n    ClientAuthError,\n    AzureRegionConfiguration,\n    AuthError,\n    Constants,\n    IAppTokenProvider,\n    OIDC_DEFAULT_SCOPES\n} from \"@azure/msal-common\";\nimport { IConfidentialClientApplication } from \"./IConfidentialClientApplication\";\nimport { OnBehalfOfRequest } from \"../request/OnBehalfOfRequest\";\nimport { ClientCredentialRequest } from \"../request/ClientCredentialRequest\";\n\n/**\n *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications\n *  will configure application secrets, client certificates/assertions as applicable\n * @public\n */\nexport class ConfidentialClientApplication extends ClientApplication implements IConfidentialClientApplication {\n    private appTokenProvider?: IAppTokenProvider;\n\n    /**\n     * Constructor for the ConfidentialClientApplication\n     *\n     * Required attributes in the Configuration object are:\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal\n     * - authority: the authority URL for your application.\n     * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.\n     *\n     * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n     *\n     * In Azure B2C, authority is of the form https://\\{instance\\}/tfp/\\{tenant\\}/\\{policyName\\}/\n     * Full B2C functionality will be available in this library in future versions.\n     *\n     * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance\n     */\n    constructor(configuration: Configuration) {\n        super(configuration);\n        this.setClientCredential(this.config);\n        this.appTokenProvider = undefined;\n    }\n\n    /**               \n     * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and\n     * is meant for Azure SDK to enhance Managed Identity support.\n     * \n     * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.     \n     */\n    SetAppTokenProvider(provider: IAppTokenProvider): void {\n        this.appTokenProvider = provider;\n    }\n\n    /**\n     * Acquires tokens from the authority for the application (not for an end user).\n     */\n    public async acquireTokenByClientCredential(request: ClientCredentialRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByClientCredential called\", request.correlationId);\n\n        // If there is a client assertion present in the request, it overrides the one present in the client configuration\n        let clientAssertion;\n        if (request.clientAssertion) {\n            clientAssertion = {\n                assertion: request.clientAssertion,\n                assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE\n            };\n        }\n\n        const baseRequest = await this.initializeBaseRequest(request);\n\n        // valid base request should not contain oidc scopes in this grant type\n        const validBaseRequest = {\n            ...baseRequest,\n            scopes: baseRequest.scopes.filter((scope: string) => !OIDC_DEFAULT_SCOPES.includes(scope))\n        };\n\n        const validRequest: CommonClientCredentialRequest = {\n            ...request,\n            ...validBaseRequest,\n            clientAssertion\n        };\n\n        const azureRegionConfiguration: AzureRegionConfiguration = {\n            azureRegion: validRequest.azureRegion,\n            environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);\n        try {\n            const clientCredentialConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                azureRegionConfiguration,\n                request.azureCloudOptions\n            );\n            const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);\n            this.logger.verbose(\"Client credential client created\", validRequest.correlationId);\n            return clientCredentialClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires tokens from the authority for the application.\n     *\n     * Used in scenarios where the current app is a middle-tier service which was called with a token\n     * representing an end user. The current app can use the token (oboAssertion) to request another\n     * token to access downstream web API, on behalf of that user.\n     *\n     * The current middle-tier app has no user interaction to obtain consent.\n     * See how to gain consent upfront for your middle-tier app from this article.\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application\n     */\n    public async acquireTokenOnBehalfOf(request: OnBehalfOfRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenOnBehalfOf called\", request.correlationId);\n        const validRequest: CommonOnBehalfOfRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request)\n        };\n        try {\n            const onBehalfOfConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                undefined,\n                undefined,\n                request.azureCloudOptions\n            );\n            const oboClient = new OnBehalfOfClient(onBehalfOfConfig);\n            this.logger.verbose(\"On behalf of client created\", validRequest.correlationId);\n            return oboClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            throw e;\n        }\n    }\n\n    private setClientCredential(configuration: Configuration): void {\n        const clientSecretNotEmpty = !StringUtils.isEmpty(configuration.auth.clientSecret);\n        const clientAssertionNotEmpty = !StringUtils.isEmpty(configuration.auth.clientAssertion);\n        const certificate = configuration.auth.clientCertificate || {\n            thumbprint: Constants.EMPTY_STRING,\n            privateKey: Constants.EMPTY_STRING\n        };\n        const certificateNotEmpty = !StringUtils.isEmpty(certificate.thumbprint) || !StringUtils.isEmpty(certificate.privateKey);\n\n        /*\n         * If app developer configures this callback, they don't need a credential\n         * i.e. AzureSDK can get token from Managed Identity without a cert / secret\n         */\n        if (this.appTokenProvider) {\n            return;\n        }\n\n        // Check that at most one credential is set on the application\n        if (\n            clientSecretNotEmpty && clientAssertionNotEmpty ||\n            clientAssertionNotEmpty && certificateNotEmpty ||\n            clientSecretNotEmpty && certificateNotEmpty) {\n            throw ClientAuthError.createInvalidCredentialError();\n        }\n\n        if (configuration.auth.clientSecret) {\n            this.clientSecret = configuration.auth.clientSecret;\n            return;\n        }\n\n        if (configuration.auth.clientAssertion) {\n            this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion);\n            return;\n        }\n\n        if (!certificateNotEmpty) {\n            throw ClientAuthError.createInvalidCredentialError();\n        } else {\n            this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, configuration.auth.clientCertificate?.x5c);\n        }\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountEntity, ICachePlugin, TokenCacheContext } from \"@azure/msal-common\";\nimport { TokenCache } from \"../TokenCache\";\nimport { IPartitionManager } from \"./IPartitionManager\";\nimport { ICacheClient } from \"./ICacheClient\";\n\nexport class DistributedCachePlugin implements ICachePlugin {\n    private client: ICacheClient;\n    private partitionManager: IPartitionManager;\n\n    constructor(client: ICacheClient, partitionManager: IPartitionManager) {\n        this.client = client;\n        this.partitionManager = partitionManager;\n    }\n  \n    public async beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void> {\n        const partitionKey = await this.partitionManager.getKey();\n        const cacheData = await this.client.get(partitionKey);\n        cacheContext.tokenCache.deserialize(cacheData);\n    }\n  \n    public async afterCacheAccess(cacheContext: TokenCacheContext): Promise<void> {\n        if (cacheContext.cacheHasChanged) {\n            const kvStore = (cacheContext.tokenCache as TokenCache).getKVStore();\n            const accountEntities = Object.values(kvStore).filter(value => AccountEntity.isAccountEntity(value as object));\n\n            if (accountEntities.length > 0) {\n                const accountEntity = accountEntities[0] as AccountEntity;\n                const partitionKey = await this.partitionManager.extractKey(accountEntity);\n                          \n                await this.client.set(partitionKey, cacheContext.tokenCache.serialize());           \n            }\n        }\n    }\n}\n"],"names":["HttpMethod","HttpStatus","ProxyStatus","REGION_ENVIRONMENT_VARIABLE","RANDOM_OCTET_SIZE","Hash","SHA256","CharSet","CV_CHARSET","Constants","MSAL_SKU","JWT_BEARER_ASSERTION_TYPE","AUTHORIZATION_PENDING","HTTP_PROTOCOL","LOCALHOST","ApiId","JwtConstants","ALGORITHM","RSA_256","X5T","X5C","AUDIENCE","EXPIRATION_TIME","ISSUER","SUBJECT","NOT_BEFORE","JWT_ID","LOOPBACK_SERVER_CONSTANTS","INTERVAL_MS","TIMEOUT_MS","NetworkUtils","getNetworkResponse","headers","body","statusCode","status","HttpClient","sendGetRequestAsync","url","options","proxyUrl","networkRequestViaProxy","GET","networkRequestViaHttps","sendPostRequestAsync","cancellationToken","POST","httpMethod","timeout","URL","destinationUrl","tunnelRequestOptions","host","hostname","port","method","path","postRequestStringContent","length","outgoingRequestString","toUpperCase","href","Promise","resolve","reject","request","http","on","destroy","Error","end","response","socket","proxyStatusCode","SERVER_ERROR","SUCCESS_RANGE_START","SUCCESS_RANGE_END","statusMessage","setTimeout","write","data","chunk","push","dataString","Buffer","concat","toString","dataStringArray","split","httpStatusCode","parseInt","slice","join","headersArray","entries","Map","forEach","header","headerKeyValue","RegExp","headerKey","headerValue","object","JSON","parse","e","set","Object","fromEntries","parsedHeaders","networkResponse","parseBody","isPostRequest","emptyHeaders","customOptions","https","parsedBody","error","errorType","errorDescriptionHelper","CLIENT_ERROR_RANGE_START","CLIENT_ERROR_RANGE_END","SERVER_ERROR_RANGE_START","SERVER_ERROR_RANGE_END","error_description","stringify","DEFAULT_AUTH_OPTIONS","clientId","EMPTY_STRING","authority","DEFAULT_AUTHORITY","clientSecret","clientAssertion","clientCertificate","thumbprint","privateKey","x5c","knownAuthorities","cloudDiscoveryMetadata","authorityMetadata","clientCapabilities","protocolMode","ProtocolMode","AAD","azureCloudOptions","azureCloudInstance","AzureCloudInstance","None","tenant","skipAuthorityMetadataCache","DEFAULT_CACHE_OPTIONS","DEFAULT_LOGGER_OPTIONS","loggerCallback","piiLoggingEnabled","logLevel","LogLevel","Info","DEFAULT_SYSTEM_OPTIONS","loggerOptions","networkClient","DEFAULT_TELEMETRY_OPTIONS","application","appName","appVersion","buildAppConfiguration","auth","cache","system","telemetry","GuidGenerator","generateGuid","uuidv4","isGuid","guid","regexGuid","test","EncodingUtils","base64Encode","str","encoding","from","base64EncodeUrl","replace","base64Decode","base64Str","base64DecodeUrl","HashUtils","sha256","buffer","crypto","createHash","update","digest","PkceGenerator","constructor","hashUtils","generatePkceCodes","verifier","generateCodeVerifier","challenge","generateCodeChallengeFromVerifier","charArr","maxNumber","byte","randomBytes","index","codeVerifier","CryptoProvider","pkceGenerator","guidGenerator","createNewGuid","input","getPublicKeyThumbprint","removeTokenBindingKey","clearKeystore","signJwt","hashString","plainText","Deserializer","deserializeJSONBlob","jsonFile","deserializedCache","StringUtils","isEmpty","deserializeAccounts","accounts","accountObjects","keys","map","key","serializedAcc","mappedAcc","homeAccountId","home_account_id","environment","realm","localAccountId","local_account_id","username","authorityType","authority_type","name","clientInfo","client_info","lastModificationTime","last_modification_time","lastModificationApp","last_modification_app","account","AccountEntity","CacheManager","toObject","deserializeIdTokens","idTokens","idObjects","serializedIdT","mappedIdT","credentialType","credential_type","client_id","secret","idToken","IdTokenEntity","deserializeAccessTokens","accessTokens","atObjects","serializedAT","mappedAT","target","cachedAt","cached_at","expiresOn","expires_on","extendedExpiresOn","extended_expires_on","refreshOn","refresh_on","keyId","key_id","tokenType","token_type","requestedClaims","requestedClaimsHash","accessToken","AccessTokenEntity","deserializeRefreshTokens","refreshTokens","rtObjects","serializedRT","mappedRT","familyId","family_id","refreshToken","RefreshTokenEntity","deserializeAppMetadata","appMetadata","appMetadataObjects","serializedAmdt","mappedAmd","amd","AppMetadataEntity","deserializeAllCache","jsonCache","Account","IdToken","AccessToken","RefreshToken","AppMetadata","Serializer","serializeJSONBlob","serializeAccounts","accCache","accountEntity","serializeIdTokens","idTCache","idTEntity","serializeAccessTokens","atCache","atEntity","serializeRefreshTokens","rtCache","rtEntity","serializeAppMetadata","amdtCache","amdtEntity","serializeAllCache","inMemCache","NodeStorage","logger","cryptoImpl","registerChangeEmitter","func","changeEmitters","emitChange","call","cacheToInMemoryCache","inMemoryCache","inMemoryCacheToCache","getCache","getInMemoryCache","trace","setInMemoryCache","setCache","getItem","tracePii","setItem","value","getAccount","accountKey","isAccountEntity","setAccount","generateAccountKey","getIdTokenCredential","idTokenKey","isIdTokenEntity","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","isAccessTokenEntity","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","isRefreshTokenEntity","setRefreshTokenCredential","getAppMetadata","appMetadataKey","isAppMetadataEntity","setAppMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetrykey","serverTelemetryEntity","ServerTelemetryEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetryKey","serverTelemetry","getAuthorityMetadata","authorityMetadataEntity","AuthorityMetadataEntity","isAuthorityMetadataEntity","getAuthorityMetadataKeys","getKeys","filter","isAuthorityMetadata","setAuthorityMetadata","metadata","getThrottlingCache","throttlingCacheKey","throttlingCache","ThrottlingEntity","isThrottlingEntity","setThrottlingCache","removeItem","result","containsKey","includes","clear","cacheKeys","generateInMemoryCache","generateJsonCache","updateCredentialCacheKey","currentCacheKey","credential","updatedCacheKey","cacheItem","verbose","defaultSerializedCache","TokenCache","storage","cachePlugin","cacheHasChanged","handleChangeEvent","bind","persistence","hasChanged","serialize","finalState","cacheSnapshot","mergeState","deserialize","overlayDefaults","getKVStore","getAllAccounts","cacheContext","TokenCacheContext","beforeCacheAccess","afterCacheAccess","getAccountByHomeId","allAccounts","accountObj","getAccountByLocalId","removeAccount","generateAccountCacheKey","oldState","currentState","stateAfterRemoval","mergeRemovals","mergeUpdates","newState","newKey","newValue","hasOwnProperty","newValueNotNull","newValueIsObject","newValueIsNotArray","Array","isArray","oldStateNotUndefinedOrNull","mergeRemovalsDict","oldKey","passedInCache","version","NodeAuthErrorMessage","invalidLoopbackAddressType","code","desc","unableToLoadRedirectUri","noAuthCodeInResponse","noLoopbackServerExists","loopbackServerAlreadyExists","loopbackServerTimeout","stateNotFoundError","NodeAuthError","AuthError","errorCode","errorMessage","createInvalidLoopbackAddressTypeError","createUnableToLoadRedirectUrlError","createNoAuthCodeInResponseError","createNoLoopbackServerExistsError","createLoopbackServerAlreadyExistsError","createLoopbackServerTimeoutError","createStateNotFoundError","ClientApplication","configuration","config","cryptoProvider","Logger","tokenCache","getAuthCodeUrl","info","correlationId","validRequest","initializeBaseRequest","responseMode","ResponseMode","QUERY","authenticationScheme","AuthenticationScheme","BEARER","authClientConfig","buildOauthClientConfiguration","undefined","authorizationCodeClient","AuthorizationCodeClient","acquireTokenByCode","authCodePayLoad","state","validateState","serverTelemetryManager","initializeServerTelemetryManager","acquireToken","setCorrelationId","cacheFailedRequest","acquireTokenByRefreshToken","refreshTokenClientConfig","refreshTokenClient","RefreshTokenClient","acquireTokenSilent","forceRefresh","silentFlowClientConfig","silentFlowClient","SilentFlowClient","acquireTokenByUsernamePassword","usernamePasswordClientConfig","usernamePasswordClient","UsernamePasswordClient","getTokenCache","cachedState","ClientAuthError","createStateMismatchError","getLogger","setLogger","requestCorrelationId","azureRegionConfiguration","userAzureCloudOptions","discoveredAuthority","createAuthority","updateRegionDiscoveryMetadata","regionDiscoveryMetadata","clientConfiguration","authOptions","systemOptions","cryptoInterface","networkInterface","storageInterface","clientCredentials","getClientAssertion","libraryInfo","sku","NodeConstants","cpu","process","arch","os","platform","persistencePlugin","serializableCache","assertion","getJwt","tokenEndpoint","assertionType","authRequest","POP","claims","scopes","OIDC_DEFAULT_SCOPES","apiId","telemetryPayload","ServerTelemetryManager","authorityString","authorityUrl","Authority","generateAuthority","authorityOptions","AuthorityFactory","createDiscoveredInstance","clearCache","LoopbackClient","listenForAuthCode","successTemplate","errorTemplate","server","authCodeListener","createServer","req","res","CommonConstants","FORWARD_SLASH","authCodeResponse","UrlString","getDeserializedQueryString","redirectUri","getRedirectUri","writeHead","REDIRECT","location","listen","ticks","id","setInterval","listening","clearInterval","address","closeServer","close","PublicClientApplication","acquireTokenByDeviceCode","assign","deviceCodeConfig","deviceCodeClient","DeviceCodeClient","acquireTokenInteractive","openBrowser","remainingProperties","loopbackClient","codeChallenge","codeChallengeMethod","CodeChallengeMethodValues","S256","authCodeUrl","finally","ServerError","suberror","tokenRequest","ClientAssertion","fromAssertion","jwt","fromCertificate","publicCertificate","parseCertificate","issuer","jwtAudience","isExpired","createJwt","createInvalidAssertionError","issuedAt","TimeUtils","nowSeconds","expirationTime","alg","x5t","payload","sign","regexToFindCerts","certs","matches","exec","ConfidentialClientApplication","setClientCredential","appTokenProvider","SetAppTokenProvider","provider","acquireTokenByClientCredential","baseRequest","validBaseRequest","scope","azureRegion","environmentRegion","env","skipCache","clientCredentialConfig","clientCredentialClient","ClientCredentialClient","acquireTokenOnBehalfOf","onBehalfOfConfig","oboClient","OnBehalfOfClient","clientSecretNotEmpty","clientAssertionNotEmpty","certificate","certificateNotEmpty","createInvalidCredentialError","DistributedCachePlugin","client","partitionManager","partitionKey","getKey","cacheData","get","kvStore","accountEntities","values","extractKey"],"mappings":"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"}